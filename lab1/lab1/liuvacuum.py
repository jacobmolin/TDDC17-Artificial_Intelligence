from random import random, Random
from agents import Environment, Agent

ENV_DIRTY = "DIRT"
ENV_CLEAN = "CLEAN"
ENV_WALL = "WALL"

ACTION_FORWARD = "FORWARD"
ACTION_SUCK = "SUCK"
ACTION_TURN_LEFT = "LEFT"
ACTION_TURN_RIGHT = "RIGHT"
ACTION_NOP = "NOP"


class Percept:
    def __init__(self, attributes):
        self.attributes = attributes


class LIUVacuumEnvironment(Environment):

    """
    Create a vacuum environment with the given width, height, world-gen element biases and PRF seed
    """
    def __init__(self, env_x=5, env_y=5, dirt_bias=0.1, wall_bias=0.0, world_seed=None):
        super().__init__()
        self.env_x = env_x
        self.env_y = env_y
        self.dirt_bias = dirt_bias
        self.wall_bias = wall_bias
        self.world = None
        self.randomize_world(world_seed)

    """
    Add thing to environment
    """
    def add_thing(self, thing, location=None):
        # Facing x=1, y=0 (EAST)
        # Note, the facing determines the thing's "active" axis.
        # I.e. x=1 implies that the x-axis is "active" for this thing
        # This is useful for ACTION_FORWARD
        thing.facing = (1, 0)
        thing.performance = -1000.0
        super().add_thing(thing, location)

    """
    Generate a percept for an agent
    """
    def percept(self, agent):
        return Percept({"home": agent.location[0] == 1 and agent.location[1] == 1,
                        "dirt": self.world[agent.location[0]][agent.location[1]] == ENV_DIRTY,
                        "bump": agent.bump})

    """
    Process actions generated by agents in environment
    """
    def execute_action(self, agent, action):

        agent.bump = False

        # Compute performance of agent based on action
        if action == ACTION_SUCK and self.world[agent.location[0]][agent.location[1]] == ENV_DIRTY:
            agent.performance += 100.0
        else:
            agent.performance -= 1.0

        # Implement action
        if action == ACTION_FORWARD:
            new_location = (agent.location[0] + agent.facing[0], agent.location[1] + agent.facing[1])
            agent.bump = self.world[new_location[0]][new_location[1]] == ENV_WALL
            agent.location = agent.location if agent.bump else new_location
        elif action == ACTION_SUCK:
            self.world[agent.location[0]][agent.location[1]] = ENV_CLEAN

        # A rotation always entails swapping the "active" axis
        # Additionally, compute sign of direction along new "active" axis compared to sign of direction along previous axis
        elif action == ACTION_TURN_LEFT:
            """
            NORTH -> WEST   |  ( 0, -1) -> (-1,  0)
            EAST  -> NORTH  |  ( 1,  0) -> ( 0, -1)
            SOUTH -> EAST   |  ( 0,  1) -> ( 1,  0)
            WEST  -> SOUTH  |  (-1,  0) -> ( 0,  1)
            """
            agent.facing = (agent.facing[1], -agent.facing[0] if agent.facing[0] != 0 else agent.facing[0])
        elif action == ACTION_TURN_RIGHT:
            agent.facing = (-agent.facing[1] if agent.facing[1] != 0 else agent.facing[1], agent.facing[0])

    """
    Start position for a given Thing in the environment
    """
    def default_location(self, thing):
        return 1, 1

    """
    Random-generate an environment for the vacuum with an optional seed
    """
    def randomize_world(self, seed=None):
        randfunc = random if seed is None else Random(seed).random

        self.world = [
            [
                ENV_WALL if
                    x == 0 or
                    x == self.env_x - 1 or
                    y == 0 or
                    y == self.env_y - 1 or
                    (randfunc() < self.wall_bias and not (x == 1 and y == 1))
                else ENV_DIRTY if randfunc() < self.dirt_bias
                else ENV_CLEAN
                for y in range(self.env_y)
            ]
            for x in range(self.env_x)
        ]
